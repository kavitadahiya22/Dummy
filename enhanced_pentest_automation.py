#!/usr/bin/env python3
"""
Enhanced Penetration Testing Automation Suite
Includes OpenSearch Dashboard Integration and PDF Report Generation
"""

import os
import sys
import subprocess
import argparse
import datetime
import json
import time
import requests
import logging
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('pentest.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EnhancedPentestAutomation:
    def __init__(self, target_url, output_dir="pentest_results"):
        self.target_url = target_url.rstrip('/')
        
        # Use environment variable for output directory if available (Docker support)
        if os.getenv('PENTEST_OUTPUT_DIR'):
            output_dir = os.getenv('PENTEST_OUTPUT_DIR')
        
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        # Create reports directory
        self.reports_dir = Path('./reports')
        self.reports_dir.mkdir(exist_ok=True)
        
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.results = {}
        self.start_time = datetime.datetime.now()
        
        # OpenSearch and Dashboard URLs
        self.opensearch_url = os.getenv('OPENSEARCH_URL', 'http://localhost:9200')
        self.dashboard_url = os.getenv('OPENSEARCH_DASHBOARD_URL', 'http://localhost:5601')
        
        # Docker-specific settings
        self.is_docker = os.path.exists('/.dockerenv') or os.getenv('DOCKER_CONTAINER') == 'true'
        if self.is_docker:
            print("üê≥ Running in Docker container")
            
        print(f"üéØ Target: {self.target_url}")
        print(f"üìä OpenSearch: {self.opensearch_url}")
        print(f"üìà Dashboard: {self.dashboard_url}")
        print(f"üìÅ Output: {self.output_dir}")
    
    def wait_for_services(self):
        """Wait for required services to be ready"""
        services = [
            (self.target_url, "Target Application"),
            (self.opensearch_url, "OpenSearch"),
            (self.dashboard_url, "OpenSearch Dashboard")
        ]
        
        for url, name in services:
            self._wait_for_service(url, name)
    
    def _wait_for_service(self, url, name, timeout=300):
        """Wait for a service to become available"""
        logger.info(f"‚è≥ Waiting for {name} at {url}")
        start_time = time.time()
        
        while time.time() - start_time < timeout:
            try:
                response = requests.get(url, timeout=5)
                if response.status_code < 500:
                    logger.info(f"‚úÖ {name} is ready")
                    return True
            except requests.exceptions.RequestException:
                pass
            
            time.sleep(5)
        
        logger.warning(f"‚ö†Ô∏è {name} not ready after {timeout}s, continuing anyway")
        return False
    
    def run_tool_script(self, tool_name, script_name):
        """Run a penetration testing tool script"""
        script_path = Path(script_name)
        if not script_path.exists():
            logger.warning(f"‚ö†Ô∏è Script {script_name} not found, skipping {tool_name}")
            return {"status": "skipped", "reason": "script not found"}
        
        logger.info(f"üîß Running {tool_name}")
        
        try:
            # Run the tool script
            result = subprocess.run(
                [sys.executable, script_name, self.target_url],
                capture_output=True,
                text=True,
                timeout=300,
                cwd=Path.cwd()
            )
            
            tool_result = {
                'status': 'success' if result.returncode == 0 else 'failed',
                'stdout': result.stdout,
                'stderr': result.stderr,
                'returncode': result.returncode,
                'timestamp': datetime.datetime.now().isoformat()
            }
            
            # Parse and extract meaningful data
            parsed_result = self._parse_tool_output(tool_name, tool_result)
            self.results[tool_name] = parsed_result
            
            logger.info(f"‚úÖ {tool_name} completed")
            return parsed_result
            
        except subprocess.TimeoutExpired:
            logger.warning(f"‚è∞ {tool_name} timed out")
            return {'status': 'timeout', 'timestamp': datetime.datetime.now().isoformat()}
        except Exception as e:
            logger.error(f"‚ùå {tool_name} failed: {e}")
            return {'status': 'error', 'error': str(e), 'timestamp': datetime.datetime.now().isoformat()}
    
    def _parse_tool_output(self, tool_name, result):
        """Parse tool output and extract vulnerabilities/findings"""
        if result['status'] != 'success':
            return result
        
        output = result['stdout']
        parsed = result.copy()
        
        try:
            # Parse different tool outputs
            if tool_name == 'nmap':
                ports = self._extract_ports(output)
                parsed['open_ports'] = ports
                parsed['findings_count'] = len(ports)
                
            elif tool_name in ['nikto', 'nuclei']:
                vulns = self._extract_vulnerabilities(output)
                parsed['vulnerabilities'] = vulns
                parsed['findings_count'] = len(vulns)
                
            elif tool_name == 'sqlmap':
                injections = self._extract_sql_injections(output)
                parsed['sql_injection_points'] = injections
                parsed['findings_count'] = len(injections)
                
            elif tool_name == 'hydra':
                creds = self._extract_credentials(output)
                parsed['valid_credentials'] = creds
                parsed['findings_count'] = len(creds)
                
            else:
                # Generic parsing for other tools
                findings = self._extract_generic_findings(output)
                parsed['findings'] = findings
                parsed['findings_count'] = len(findings)
                
        except Exception as e:
            logger.warning(f"Failed to parse {tool_name} output: {e}")
            parsed['findings_count'] = 0
        
        return parsed
    
    def _extract_ports(self, output):
        """Extract open ports from nmap output"""
        ports = []
        for line in output.split('\n'):
            if '/tcp' in line and 'open' in line:
                port = line.split('/')[0].strip()
                if port.isdigit():
                    ports.append(int(port))
        return ports
    
    def _extract_vulnerabilities(self, output):
        """Extract vulnerabilities from scanner output"""
        vulns = []
        for line in output.split('\n'):
            line = line.strip()
            if any(keyword in line.lower() for keyword in ['vulnerability', 'cve-', 'osvdb-', 'exploit']):
                vulns.append({
                    "description": line,
                    "severity": self._assess_severity(line),
                    "type": "vulnerability"
                })
        return vulns
    
    def _extract_sql_injections(self, output):
        """Extract SQL injection findings"""
        injections = []
        if 'injection' in output.lower():
            # Look for specific SQL injection indicators
            for line in output.split('\n'):
                if any(keyword in line.lower() for keyword in ['injection', 'vulnerable', 'payload']):
                    injections.append(line.strip())
        return injections
    
    def _extract_credentials(self, output):
        """Extract valid credentials from brute force output"""
        creds = []
        for line in output.split('\n'):
            if 'valid' in line.lower() or 'success' in line.lower():
                if ':' in line:
                    creds.append(line.strip())
        return creds
    
    def _extract_generic_findings(self, output):
        """Extract generic findings from tool output"""
        findings = []
        lines = output.split('\n')
        for line in lines:
            line = line.strip()
            if line and len(line) > 10:  # Skip empty or very short lines
                findings.append(line)
        return findings[:20]  # Limit to first 20 findings
    
    def _assess_severity(self, finding):
        """Assess severity based on finding content"""
        finding_lower = finding.lower()
        if any(word in finding_lower for word in ['critical', 'remote code execution', 'sql injection']):
            return 'Critical'
        elif any(word in finding_lower for word in ['high', 'authentication bypass', 'privilege escalation']):
            return 'High'
        elif any(word in finding_lower for word in ['medium', 'xss', 'csrf']):
            return 'Medium'
        else:
            return 'Low'
    
    def run_comprehensive_pentest(self):
        """Run comprehensive penetration testing suite"""
        logger.info("üöÄ Starting Enhanced Penetration Testing")
        logger.info("=" * 60)
        
        # Wait for services
        self.wait_for_services()
        
        # Define tool phases
        phases = {
            "Reconnaissance": [
                ("nmap", "tools/nmap.py"),
                ("amass", "tools/amass.py")
            ],
            "Vulnerability Assessment": [
                ("nikto", "tools/nikto.py"),
                ("nuclei", "tools/nuclei.py"),
                ("dirb", "tools/dirb.py"),
                ("gobuster", "tools/gobuster.py")
            ],
            "Exploitation": [
                ("sqlmap", "tools/sqlmap.py"),
                ("hydra", "tools/hydra.py"),
                ("xss", "tools/xss.py"),
                ("csrf", "tools/csrf.py")
            ],
            "Post-Exploitation": [
                ("session_analysis", "tools/session_analyzer.py"),
                ("privilege_escalation", "tools/privilege_escalation.py")
            ]
        }
        
        # Run each phase
        for phase_name, tools in phases.items():
            logger.info(f"üîç Phase: {phase_name}")
            
            # Run tools in parallel within each phase
            with ThreadPoolExecutor(max_workers=3) as executor:
                futures = {
                    executor.submit(self.run_tool_script, tool_name, script_name): tool_name 
                    for tool_name, script_name in tools
                }
                
                for future in as_completed(futures):
                    tool_name = futures[future]
                    try:
                        result = future.result()
                        status = result.get('status', 'unknown')
                        findings = result.get('findings_count', 0)
                        logger.info(f"üìã {tool_name}: {status} ({findings} findings)")
                    except Exception as e:
                        logger.error(f"‚ùå {tool_name} failed: {e}")
        
        # Save results
        results_file = self.save_results()
        
        # Integration and reporting
        if results_file:
            self.integrate_opensearch(results_file)
            pdf_file = self.generate_pdf_report(results_file)
            
            # Final summary
            self.print_summary(results_file, pdf_file)
        
        return True
    
    def save_results(self):
        """Save all results to JSON file"""
        results_file = self.output_dir / f"pentest_results_{self.timestamp}.json"
        
        # Calculate summary statistics
        total_findings = sum(r.get('findings_count', 0) for r in self.results.values())
        successful_tools = sum(1 for r in self.results.values() if r.get('status') == 'success')
        
        final_results = {
            'metadata': {
                'target_url': self.target_url,
                'start_time': self.start_time.isoformat(),
                'end_time': datetime.datetime.now().isoformat(),
                'duration': str(datetime.datetime.now() - self.start_time),
                'total_tools': len(self.results),
                'successful_tools': successful_tools,
                'total_findings': total_findings,
                'opensearch_url': self.opensearch_url,
                'dashboard_url': self.dashboard_url
            },
            'results': self.results,
            'summary': {
                'critical_findings': 0,  # These would be calculated based on actual parsing
                'high_findings': 0,
                'medium_findings': 0,
                'low_findings': 0
            }
        }
        
        try:
            with open(results_file, 'w') as f:
                json.dump(final_results, f, indent=2, default=str)
            
            logger.info(f"üíæ Results saved to {results_file}")
            return results_file
            
        except Exception as e:
            logger.error(f"‚ùå Failed to save results: {e}")
            return None
    
    def integrate_opensearch(self, results_file):
        """Integrate results with OpenSearch dashboard"""
        try:
            logger.info("üìä Integrating with OpenSearch Dashboard")
            
            # Set environment variable for the integration script
            env = os.environ.copy()
            env['RESULTS_FILE'] = str(results_file)
            
            result = subprocess.run(
                [sys.executable, 'opensearch_integration.py'],
                env=env,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if result.returncode == 0:
                logger.info("‚úÖ OpenSearch integration completed")
            else:
                logger.warning(f"‚ö†Ô∏è OpenSearch integration issues: {result.stderr}")
                
        except Exception as e:
            logger.error(f"‚ùå OpenSearch integration failed: {e}")
    
    def generate_pdf_report(self, results_file):
        """Generate attractive PDF report"""
        try:
            logger.info("üìÑ Generating PDF Report")
            
            # Set environment variable for the PDF generator
            env = os.environ.copy()
            env['RESULTS_FILE'] = str(results_file)
            
            result = subprocess.run(
                [sys.executable, 'pdf_report_generator.py'],
                env=env,
                capture_output=True,
                text=True,
                timeout=180
            )
            
            if result.returncode == 0:
                logger.info("‚úÖ PDF report generated successfully")
                
                # Find the generated PDF
                pdf_files = list(self.reports_dir.glob('*.pdf'))
                if not pdf_files:
                    pdf_files = list(Path('.').glob('pentest_report_*.pdf'))
                
                if pdf_files:
                    latest_pdf = max(pdf_files, key=lambda f: f.stat().st_mtime)
                    return latest_pdf
            else:
                logger.warning(f"‚ö†Ô∏è PDF generation issues: {result.stderr}")
                
        except Exception as e:
            logger.error(f"‚ùå PDF generation failed: {e}")
        
        return None
    
    def print_summary(self, results_file, pdf_file=None):
        """Print comprehensive summary of the pentest"""
        logger.info("üéâ Enhanced Penetration Testing Complete!")
        logger.info("=" * 60)
        
        # Calculate statistics
        total_findings = sum(r.get('findings_count', 0) for r in self.results.values())
        successful_tools = sum(1 for r in self.results.values() if r.get('status') == 'success')
        duration = datetime.datetime.now() - self.start_time
        
        logger.info(f"üìä Results File: {results_file}")
        if pdf_file:
            logger.info(f"üìÑ PDF Report: {pdf_file}")
        logger.info(f"üéØ Dashboard: {self.dashboard_url}/app/dashboards")
        logger.info(f"‚è±Ô∏è Duration: {duration}")
        logger.info(f"‚úÖ Tools Executed: {successful_tools}/{len(self.results)}")
        logger.info(f"üîç Total Findings: {total_findings}")
        
        # Top findings by tool
        logger.info("\nüìã Findings by Tool:")
        for tool_name, result in self.results.items():
            if result.get('status') == 'success':
                findings = result.get('findings_count', 0)
                logger.info(f"  ‚Ä¢ {tool_name}: {findings} findings")
        
        print("\nüéØ Next Steps:")
        print("  1. Access the OpenSearch Dashboard for real-time analysis")
        print("  2. Review the PDF report for detailed findings")
        print("  3. Prioritize remediation based on severity levels")
        print("  4. Re-run testing after implementing fixes")

def main():
    """Main function"""
    parser = argparse.ArgumentParser(description="Enhanced Penetration Testing Automation")
    parser.add_argument("target_url", help="Target URL to test")
    parser.add_argument("--output", "-o", default="pentest_results", help="Output directory")
    
    args = parser.parse_args()
    
    print("üõ°Ô∏è  ENHANCED PENETRATION TESTING SUITE")
    print("üéØ With OpenSearch Dashboard & PDF Reports")
    print("=" * 60)
    
    # Initialize and run enhanced assessment
    pentest = EnhancedPentestAutomation(args.target_url, args.output)
    success = pentest.run_comprehensive_pentest()
    
    return 0 if success else 1

if __name__ == "__main__":
    # Handle both direct execution and Docker environment
    if len(sys.argv) == 1 and os.getenv('TARGET_URL'):
        # Running in Docker with environment variable
        sys.argv.append(os.getenv('TARGET_URL'))
    
    sys.exit(main())
