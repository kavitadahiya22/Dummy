#!/usr/bin/env python3
"""
OWASP Juice Shop Penetration Testing Automation Suite
Comprehensive pentest using multiple security tools
"""

import os
import sys
import subprocess
import argparse
import datetime
import json
from pathlib import Path

class PentestAutomation:
    def __init__(self, target_url, output_dir="pentest_results"):
        self.target_url = target_url.rstrip('/')
        
        # Use environment variable for output directory if available (Docker support)
        if os.getenv('PENTEST_OUTPUT_DIR'):
            output_dir = os.getenv('PENTEST_OUTPUT_DIR')
        
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        self.results = {}
        
        # Docker-specific settings
        self.is_docker = os.path.exists('/.dockerenv') or os.getenv('DOCKER_CONTAINER') == 'true'
        if self.is_docker:
            self.log("üê≥ Running in Docker container")
        
    def log(self, message):
        """Log messages with timestamp"""
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{timestamp}] {message}")
        
    def run_tool(self, tool_name, script_path, additional_args=None):
        """Run a penetration testing tool and capture results"""
        self.log(f"Starting {tool_name}...")
        
        try:
            cmd = [sys.executable, script_path, self.target_url]
            if additional_args:
                cmd.extend(additional_args)
                
            result = subprocess.run(
                cmd, 
                capture_output=True, 
                text=True, 
                timeout=1800  # 30 minute timeout
            )
            
            output_file = self.output_dir / f"{tool_name}_{self.timestamp}.txt"
            with open(output_file, 'w') as f:
                f.write(f"Command: {' '.join(cmd)}\n")
                f.write(f"Return code: {result.returncode}\n")
                f.write(f"STDOUT:\n{result.stdout}\n")
                f.write(f"STDERR:\n{result.stderr}\n")
                
            self.results[tool_name] = {
                'status': 'completed' if result.returncode == 0 else 'error',
                'output_file': str(output_file),
                'return_code': result.returncode
            }
            
            self.log(f"{tool_name} completed with return code {result.returncode}")
            
        except subprocess.TimeoutExpired:
            self.log(f"{tool_name} timed out after 30 minutes")
            self.results[tool_name] = {'status': 'timeout'}
        except Exception as e:
            self.log(f"Error running {tool_name}: {str(e)}")
            self.results[tool_name] = {'status': 'failed', 'error': str(e)}
    
    def phase1_reconnaissance(self):
        """Phase 1: Reconnaissance and Enumeration"""
        self.log("=== PHASE 1: RECONNAISSANCE & ENUMERATION ===")
        
        # Subdomain enumeration
        if os.path.exists("tools/amass.py"):
            self.run_tool("amass", "tools/amass.py")
        
        # Port scanning and service detection
        if os.path.exists("tools/nmap.py"):
            self.run_tool("nmap", "tools/nmap.py")
        
        # Web server vulnerability scanning
        if os.path.exists("tools/nikto.py"):
            self.run_tool("nikto", "tools/nikto.py")
    
    def phase2_vulnerability_scanning(self):
        """Phase 2: Vulnerability Scanning"""
        self.log("=== PHASE 2: VULNERABILITY SCANNING ===")
        
        # Automated vulnerability scanning
        if os.path.exists("tools/nuclei.py"):
            self.run_tool("nuclei", "tools/nuclei.py")
        
        # OWASP ZAP web application scanning
        if os.path.exists("tools/zap.py"):
            self.run_tool("zap", "tools/zap.py")
    
    def phase3_exploitation(self, username=None, password_list=None):
        """Phase 3: Exploitation"""
        self.log("=== PHASE 3: EXPLOITATION ===")
        
        # SQL injection testing
        if os.path.exists("tools/sqlmap.py"):
            self.run_tool("sqlmap", "tools/sqlmap.py")
        
        # Brute-force attacks
        if os.path.exists("tools/hydra.py") and username and password_list:
            self.run_tool("hydra", "tools/hydra.py", [username, password_list])
        
        # Metasploit exploitation
        if os.path.exists("tools/metasploit.py"):
            self.run_tool("metasploit", "tools/metasploit.py")
    
    def phase4_post_exploitation(self):
        """Phase 4: Post-Exploitation & Analysis"""
        self.log("=== PHASE 4: POST-EXPLOITATION & ANALYSIS ===")
        
        # Active Directory enumeration (if applicable)
        if os.path.exists("tools/bloodhound.py"):
            self.run_tool("bloodhound", "tools/bloodhound.py")
        
        # Credential validation and lateral movement
        if os.path.exists("tools/crackmapexec.py"):
            self.run_tool("crackmapexec", "tools/crackmapexec.py")
    
    def generate_report(self):
        """Generate a comprehensive penetration test report"""
        self.log("=== GENERATING FINAL REPORT ===")
        
        report_file = self.output_dir / f"pentest_report_{self.timestamp}.json"
        report_data = {
            'target': self.target_url,
            'timestamp': self.timestamp,
            'results': self.results,
            'summary': {
                'total_tools': len(self.results),
                'successful': len([r for r in self.results.values() if r.get('status') == 'completed']),
                'failed': len([r for r in self.results.values() if r.get('status') == 'error']),
                'timeout': len([r for r in self.results.values() if r.get('status') == 'timeout'])
            }
        }
        
        with open(report_file, 'w') as f:
            json.dump(report_data, f, indent=2)
        
        self.log(f"Report saved to: {report_file}")
        return report_file
    
    def run_full_pentest(self, username=None, password_list=None):
        """Run the complete penetration test"""
        self.log(f"Starting full penetration test against: {self.target_url}")
        self.log(f"Results will be saved to: {self.output_dir}")
        
        # Run all phases
        self.phase1_reconnaissance()
        self.phase2_vulnerability_scanning()
        self.phase3_exploitation(username, password_list)
        self.phase4_post_exploitation()
        
        # Generate final report
        report_file = self.generate_report()
        
        self.log("Penetration test completed!")
        return report_file

def main():
    parser = argparse.ArgumentParser(description="OWASP Juice Shop Penetration Testing Automation")
    parser.add_argument("target", help="Target URL (e.g., http://localhost:3000)")
    parser.add_argument("-u", "--username", help="Username for brute-force attacks")
    parser.add_argument("-p", "--password-list", help="Password list file for brute-force attacks")
    parser.add_argument("-o", "--output", default="pentest_results", help="Output directory")
    
    args = parser.parse_args()
    
    # Create and run penetration test
    pentest = PentestAutomation(args.target, args.output)
    report_file = pentest.run_full_pentest(args.username, args.password_list)
    
    print(f"\nPenetration test completed! Report saved to: {report_file}")

if __name__ == "__main__":
    main()
